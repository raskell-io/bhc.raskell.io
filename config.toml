# Zola configuration for bhc website
# https://www.getzola.org/documentation/getting-started/configuration/

base_url = "https://bhc.raskell.io"
title = "BHC - Basel Haskell Compiler"
description = "An alternative compiler for Haskell: compatibility-first, with a modern runtime, multiple targets, and opt-in extensions."
default_language = "en"
theme = "brutalist-blueprint"

# Compile Sass/SCSS
compile_sass = true

# Generate feed
generate_feeds = false

# Build options
build_search_index = false
minify_html = true

[markdown]
smart_punctuation = true
external_links_target_blank = true
external_links_no_follow = true
external_links_no_referrer = true

[markdown.highlighting]
enabled = true
light_theme = "catppuccin-latte"
dark_theme = "catppuccin-mocha"

[slugify]
paths = "on"
anchors = "on"

[extra]
# Theme mode
mode = "product"

# Brand
brand_short = "BHC"

# Site metadata
author = "raskell.io"
author_type = "Organization"
github_repo = "https://github.com/raskell-io/bhc"
docs_url = "/get-started/"

# SEO metadata
keywords = "haskell, compiler, alternative, ghc compatible, runtime profiles, wasm, numeric, tensor, structured concurrency"
og_image = "img/og-image.png"
og_image_width = 1200
og_image_height = 630
og_image_alt = "BHC - Basel Haskell Compiler: An alternative compiler for Haskell"
twitter_handle = "@raskelll"

# Favicon
favicon = "favicon.ico"
favicon_png = "favicon.png"
icon_192 = "icon-192.png"
apple_touch_icon = "apple-touch-icon.png"
webmanifest = "site.webmanifest"

# Social links
github = "https://github.com/raskell-io/bhc"

# Product configuration
[extra.product]
tagline = "Basel Haskell Compiler"
tagline_sub = "Compatibility-first. Profiles for performance."
subtitle = "An alternative compiler for Haskell with a modern runtime, multiple targets, and opt-in extensions."
gradient_title = true
badge = "alpha"
badge_url = "https://github.com/raskell-io/bhc"
features_title = "Capabilities"
features_subtitle = "BHC extends standard Haskell with runtime profiles, a tensor-native numeric pipeline, and compilation targets beyond native binaries. Same language, more options."
footer_tagline = "Functional. Portable. Fast. Haskell that ships."
footer_note = "© 2025 raskell.io. Released under the MIT License."

# Install methods for dropdown
[[extra.product.install_methods]]
id = "script"
label = "Script"
command = "curl -fsSL https://bhc.raskell.io/install.sh | sh"
icon = """<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="m10 8 4 4-4 4"/></svg>"""
default = true

[[extra.product.install_methods]]
id = "cargo"
label = "Cargo"
command = "cargo install bhc"
icon = """<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><g fill="none" fill-rule="evenodd" stroke="currentColor" stroke-linejoin="round" stroke-width="1"><path stroke-linecap="round" d="M1.5 7L8 10.5L14.5 7m-10-2.5l3.503 2L14.498 3M4.5 5.5v7m3.5-6V14"/><path stroke-linecap="round" d="M8.003 3L11.5 4.5v8"/><path stroke-linecap="square" d="M1.5 6.984V11l6.503 3.5L14.5 11V3L11 1.5l-6.5 3v1z"/></g></svg>"""

[[extra.product.features]]
title = "Compatibility-first"
description = "Targets Haskell 2010 and selected GHC editions. Use existing .cabal files and Hackage packages. Your code works unchanged."
icon = """<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 3h5v5"/><path d="M8 3H3v5"/><path d="M12 22v-8.3a4 4 0 0 0-1.172-2.872L3 3"/><path d="m15 9 6-6"/></svg>"""

[[extra.product.features]]
title = "Runtime profiles"
description = "Same source language, different runtime contracts. Choose default, server, numeric, or edge profiles per package."
icon = """<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="6" height="6" rx="1"/><rect x="14" y="4" width="6" height="6" rx="1"/><rect x="4" y="14" width="6" height="6" rx="1"/><rect x="14" y="14" width="6" height="6" rx="1"/></svg>"""

[[extra.product.features]]
title = "Numeric performance"
description = "Tensor-native pipeline, guaranteed fusion patterns, SIMD lowering. Predictable performance for numeric workloads."
icon = """<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></svg>"""

[[extra.product.features]]
title = "Multiple targets"
description = "Native compilation for servers, WASI/WASM for sandboxed compute and edge. Haskell doesn't mean one runtime on one OS."
icon = """<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 3h12l4 6-10 13L2 9Z"/><path d="M11 3 8 9l4 13 4-13-3-6"/><path d="M2 9h20"/></svg>"""

[[extra.product.features]]
title = "Structured concurrency"
description = "Server profile brings cancellation, deadlines, and scoping. Observability hooks for tracing and debugging."
icon = """<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"/><path d="m9 12 2 2 4-4"/></svg>"""

[[extra.product.features]]
title = "Opt-in extensions"
description = "BHC innovations are explicit. Enable BHC2026 bundle or individual BHC.* extensions. Stay portable or specialize."
icon = """<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>"""

# Benchmark highlights
[extra.product.benchmarks]
enabled = false

# Runtime profiles with examples
[[extra.product.profiles]]
id = "default"
name = "Default"
description = "General-purpose compilation. Focuses on correctness and GHC compatibility. Suitable for most applications."
example_file = "Main.hs"
example_code = """module Main where

-- | Standard Haskell 2010 application compiled with the default profile.
-- This code works identically with GHC and BHC, prioritizing correctness
-- and compatibility over aggressive optimization.

import Data.List (sort, foldl')
import Text.Printf (printf)

-- | Entry point: idiomatic Haskell with lazy evaluation preserved.
-- The default profile maintains GHC's evaluation semantics exactly.
main :: IO ()
main = do
    let numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
    putStrLn "Statistics for input list:"
    printf "  Sorted:  %s\\n" (show $ sort numbers)
    printf "  Sum:     %d\\n" (sumStrict numbers)
    printf "  Mean:    %.2f\\n" (mean numbers)

-- | Strict left fold to avoid space leaks.
-- Even in default profile, explicit strictness is respected.
sumStrict :: [Int] -> Int
sumStrict = foldl' (+) 0

-- | Calculate arithmetic mean of a list.
-- Uses standard Haskell idioms that work with any Haskell compiler.
mean :: [Int] -> Double
mean xs = fromIntegral (sumStrict xs) / fromIntegral (length xs)"""
usage = "bhc Main.hs"

[[extra.product.profiles]]
id = "server"
name = "Server"
description = "Structured concurrency, cancellation, deadlines. Built-in observability hooks for production services."
example_file = "Server.hs"
example_code = """{-# LANGUAGE BHC.StructuredConcurrency #-}
module Server where

-- | Production-grade request handler using BHC's server profile.
-- Structured concurrency ensures all spawned tasks are properly
-- cancelled if the parent scope exits (timeout, error, or completion).

import Control.Concurrent.Scoped
import Control.Concurrent.Deadline
import Control.Concurrent.Trace (withSpan)

-- | Handle an API request with automatic resource management.
-- The Scoped monad tracks all async operations; nothing leaks.
handler :: Request -> Scoped Response
handler req = withSpan "handleRequest" $ do
    -- 5 second timeout for the entire operation.
    -- If exceeded, all child tasks are cancelled automatically.
    withTimeout 5000 $ do
        -- Spawn concurrent database queries within this scope.
        -- These run in parallel, not sequentially.
        userData  <- async $ fetchUser req.userId
        orderData <- async $ fetchOrders req.userId
        inventory <- async $ checkInventory req.items

        -- Await all results. If any task fails or times out,
        -- the others are cancelled and resources are cleaned up.
        user   <- await userData
        orders <- await orderData
        stock  <- await inventory

        -- Observability: spans are auto-nested, traces exported.
        return $ Response user orders stock"""
usage = "bhc --profile=server Server.hs"

[[extra.product.profiles]]
id = "numeric"
name = "Numeric"
description = "Strict-by-default in hot paths, unboxed numerics, tensor lowering, SIMD. For computational workloads."
example_file = "Compute.hs"
example_code = """{-# LANGUAGE BHC.TensorIR #-}
{-# LANGUAGE BHC.StrictDefault #-}
module Compute where

-- | High-performance matrix operations using BHC's tensor IR.
-- BHC.StrictDefault eliminates thunk buildup in numeric code.
-- BHC.TensorIR enables shape-aware fusion and SIMD lowering.

import BHC.Tensor (Tensor, Matrix)
import qualified BHC.Tensor as T

-- | Matrix multiplication with automatic vectorization.
-- The compiler tracks dimensions and selects optimal block sizes.
matmul :: Matrix Float -> Matrix Float -> Matrix Float
matmul a b = T.contract a b [1] [0]

-- | L2 normalization with guaranteed single-pass fusion.
-- This compiles to: sqrt(sum(x*x)), then x/norm in one loop.
-- No intermediate tensor is allocated for (t * t).
normalize :: Tensor Float -> Tensor Float
normalize t = t / T.sqrt (T.sum (t * t))

-- | Neural network forward pass fragment.
-- The entire pipeline fuses: matmul -> normalize -> sum
-- becomes a single cache-efficient traversal with SIMD.
forward :: Matrix Float -> Matrix Float -> Float
forward input weights = T.sum (normalize (matmul input weights))

-- | Softmax with numeric stability (subtract max first).
-- Three logical passes fuse into two actual traversals.
softmax :: Tensor Float -> Tensor Float
softmax v = T.map (/ total) exps
  where
    maxVal = T.maximum v
    exps   = T.map (\\x -> exp (x - maxVal)) v
    total  = T.sum exps"""
usage = "bhc --profile=numeric Compute.hs"

[[extra.product.profiles]]
id = "edge"
name = "Edge"
description = "Minimal runtime footprint for WASM and embedded targets. Reduced GC, smaller binaries."
example_file = "Lambda.hs"
example_code = """module Lambda where

-- | Serverless function compiled for WebAssembly deployment.
-- The edge profile minimizes runtime size and memory usage,
-- producing small binaries suitable for CDN edge workers.

import Data.List (foldl')

-- | Export function for the WASM host environment to call.
-- This is the entry point invoked by Cloudflare Workers,
-- Fastly Compute, or any WASI-compatible runtime.
foreign export ccall processRequest :: Int -> Int

-- | Main request handler. Pure computation with no IO,
-- allowing aggressive optimization and dead code elimination.
processRequest :: Int -> Int
processRequest n
    | n <= 0    = 0
    | otherwise = fibonacci n + sumRange n

-- | Fibonacci sequence, optimized for small code size.
-- The edge profile favors compact output over raw speed.
fibonacci :: Int -> Int
fibonacci n
    | n <= 1    = n
    | otherwise = fibonacci (n - 1) + fibonacci (n - 2)

-- | Sum integers from 1 to n using strict fold.
-- Minimal allocation: runs in constant stack space.
sumRange :: Int -> Int
sumRange n = foldl' (+) 0 [1..n]

-- | Helper for JSON-like output (no dependencies).
-- Edge profile encourages zero-dependency code.
encodeInt :: Int -> String
encodeInt = show"""
usage = "bhc --profile=edge --target=wasm32-wasi Lambda.hs"

[[extra.product.profiles]]
id = "realtime"
name = "Realtime"
description = "Bounded GC pauses, predictable latency, arena allocation. For games, audio, and robotics."
example_file = "AudioEngine.hs"
example_code = """{-# LANGUAGE BHC.Realtime #-}
module AudioEngine where

-- | Audio processing with hard latency requirements.
-- The realtime profile guarantees bounded GC pauses (<1ms)
-- and provides arena allocators for per-frame allocation.

import BHC.Realtime.Arena (Arena, withArena, alloc)
import BHC.Realtime.Audio (Sample, SampleRate, Buffer)
import Data.Vector.Storable (Vector)
import qualified Data.Vector.Storable as V

-- | Audio callback invoked by the system at regular intervals.
-- Must complete within the buffer period (e.g., 5ms for 48kHz/256 samples).
-- Arena allocation ensures no GC occurs during processing.
processAudio :: Arena -> Buffer Sample -> Buffer Sample -> IO ()
processAudio arena input output = withArena arena $ do
    -- All allocations in this block use the arena.
    -- Memory is freed in bulk when the arena resets (per frame).
    let filtered = applyLowPass 0.3 input
    let amplified = V.map (* 0.8) filtered

    -- Copy result to output buffer (pre-allocated by host).
    V.copy output amplified

-- | Low-pass filter with no heap allocation.
-- Intermediate vectors allocated in arena, not GC heap.
applyLowPass :: Double -> Buffer Sample -> Buffer Sample
applyLowPass cutoff buf = V.zipWith blend buf smoothed
  where
    smoothed = V.scanl' (\\acc x -> acc + realToFrac cutoff * (x - acc)) 0 buf
    blend orig filt = 0.7 * orig + 0.3 * filt

-- | Game loop tick with deterministic timing.
-- Realtime profile: GC only runs between frames, never during.
gameTick :: Arena -> GameState -> GameState
gameTick arena state = withArena arena $
    updatePhysics . processInput . updateEntities $ state"""
usage = "bhc --profile=realtime AudioEngine.hs"

[[extra.product.profiles]]
id = "embedded"
name = "Embedded"
description = "No GC, static allocation, bare-metal targets. For microcontrollers and safety-critical systems."
example_file = "Firmware.hs"
example_code = """{-# LANGUAGE BHC.Embedded #-}
{-# LANGUAGE BHC.NoGC #-}
module Firmware where

-- | Bare-metal firmware for a microcontroller.
-- The embedded profile eliminates the garbage collector entirely.
-- All memory must be statically allocated or stack-based.

import BHC.Embedded.GPIO (Pin, pinMode, digitalWrite, INPUT, OUTPUT)
import BHC.Embedded.Static (StaticArray, staticArray, readAt, writeAt)
import Data.Word (Word8, Word16)

-- | Statically allocated sensor buffer (no heap).
-- Size known at compile time, lives in .data section.
{-# NOINLINE sensorBuffer #-}
sensorBuffer :: StaticArray 64 Word16
sensorBuffer = staticArray 0

-- | Main firmware entry point. Runs forever, no allocation.
-- All computation uses registers and stack only.
foreign export ccall main :: IO ()
main :: IO ()
main = do
    -- Initialize GPIO pins
    pinMode led OUTPUT
    pinMode button INPUT

    -- Event loop: poll, process, actuate
    forever $ do
        reading <- readSensor
        writeAt sensorBuffer 0 reading
        when (reading > threshold) $
            digitalWrite led True

-- | Read ADC value. Pure register access, no allocation.
readSensor :: IO Word16
readSensor = peek sensorRegister

-- | Hardware addresses (memory-mapped IO).
led, button :: Pin
led    = Pin 13
button = Pin 2

threshold :: Word16
threshold = 512

sensorRegister :: Ptr Word16
sensorRegister = wordPtrToPtr 0x40001234"""
usage = "bhc --profile=embedded --target=thumbv7m-none-eabi Firmware.hs"

# FAQ
[[extra.product.faq]]
question = "Is BHC a fork of GHC?"
answer = "No. BHC is a clean-slate compiler written in Rust. It targets the Haskell 2026 Platform specification and prioritizes predictable performance, structured concurrency, and a tensor-native numeric pipeline. It does not share code with GHC."

[[extra.product.faq]]
question = "Can I use my existing Haskell packages?"
answer = "BHC is actively working on real-world Haskell compatibility (M11). It supports LANGUAGE pragmas, the Haskell 2010 layout rule, the full module system, type classes, and many common extensions. Check the compatibility page for current status."

[[extra.product.faq]]
question = "What are runtime profiles?"
answer = "Profiles are compile-time configurations with different performance contracts. <strong>Default</strong>: lazy evaluation, GC-managed. <strong>Server</strong>: structured concurrency, observability. <strong>Numeric</strong>: strict-by-default, guaranteed fusion. <strong>Edge</strong>: minimal runtime for WASM. <strong>Realtime</strong>: bounded GC pauses for games/audio. <strong>Embedded</strong>: no GC, bare-metal targets."

[[extra.product.faq]]
question = "What makes the Numeric profile special?"
answer = "The Numeric profile guarantees fusion for standard patterns like <code>map f (map g x)</code> and <code>sum (map f x)</code>. No hidden allocations, SIMD auto-vectorization, and a Tensor IR that tracks shapes and strides. Fusion failure is a compiler bug."

[[extra.product.faq]]
question = "Does BHC support GPUs?"
answer = "Yes. The GPU backend generates CUDA and ROCm code for tensor operations. Write standard Haskell with tensor syntax; the compiler handles GPU code generation and memory transfers automatically."

[[extra.product.faq]]
question = "What about WebAssembly?"
answer = "BHC can target WASM for browser and edge deployment. Use <code>--target wasm32-wasi</code> with the Edge profile for minimal runtime footprint. SIMD128 is supported for numeric workloads."

[[extra.product.faq]]
question = "Is BHC production-ready?"
answer = "BHC has completed milestones M0–M10 (core compiler, profiles, GPU, WASM, diagnostics). M11 focusing on real-world Haskell compatibility is in progress. Suitable for new projects; existing codebases increasingly supported."

[[extra.product.faq]]
question = "How do I report bugs or contribute?"
answer = "Open an issue or discussion on <a href=\"https://github.com/raskell-io/bhc\" target=\"_blank\" rel=\"noopener\">GitHub</a>. We follow conventional commits and welcome contributions. See CLAUDE.md for development guidelines."

[[extra.product.faq]]
question = "Does BHC work with Cabal and Stack?"
answer = "Yes. BHC reads <code>.cabal</code> files directly and resolves dependencies from Hackage. Use <code>bhc build</code> as a drop-in for <code>cabal build</code>. Stack support is planned. Existing project files work without modification."

[[extra.product.faq]]
question = "How do I migrate a project from GHC?"
answer = "Start with <code>bhc check</code> to identify compatibility issues. Most pure Haskell code compiles unchanged. Check the <a href=\"/compatibility/\">compatibility page</a> for extension support. Migration is incremental—you can compile some modules with BHC while others use GHC."

[[extra.product.faq]]
question = "Which GHC extensions are supported?"
answer = "BHC supports most common extensions: GADTs, TypeFamilies, DataKinds, RankNTypes, FlexibleContexts, and more. Template Haskell has partial support. See the <a href=\"/compatibility/\">compatibility charter</a> for the full list and known gaps."

[[extra.product.faq]]
question = "Why is BHC written in Rust?"
answer = "Rust provides memory safety, predictable performance, and excellent tooling. A clean-slate implementation lets us design a modern compiler architecture without legacy constraints. The choice has no effect on the Haskell code you write."

[[extra.product.faq]]
question = "Does BHC use LLVM?"
answer = "Yes. BHC uses LLVM for native code generation, just like GHC (optionally), Rust, Swift, and many other modern compilers. LLVM provides battle-tested optimizations, broad target support (x86, ARM, RISC-V), and SIMD auto-vectorization. The GPU backends generate PTX/AMDGCN directly, while the WASM backend emits WebAssembly without LLVM."

[[extra.product.faq]]
question = "How are BHC's error messages?"
answer = "BHC prioritizes clear diagnostics. Error messages include source spans, suggested fixes, and explanations. Type errors show the full unification trace when needed. Use <code>--explain E0123</code> for detailed documentation on any error code."

[[extra.product.faq]]
question = "Can BHC cross-compile?"
answer = "Yes. BHC supports multiple targets from a single installation: native (x86_64, aarch64), WebAssembly (wasm32-wasi), and embedded (ARM Cortex-M, RISC-V). Use <code>--target</code> to specify. No separate toolchain installation required for WASM."

# Social links
[extra.social]
github = "https://github.com/raskell-io/bhc"
twitter = "https://x.com/raskelll"

# Footer link groups
[[extra.product.footer_links]]
title = "Documentation"
[[extra.product.footer_links.links]]
text = "Get Started"
url = "/get-started/"
[[extra.product.footer_links.links]]
text = "Compatibility"
url = "/compatibility/"
[[extra.product.footer_links.links]]
text = "Profiles"
url = "/profiles/"
[[extra.product.footer_links.links]]
text = "Numeric"
url = "/numeric/"

[[extra.product.footer_links]]
title = "Resources"
[[extra.product.footer_links.links]]
text = "GitHub"
url = "https://github.com/raskell-io/bhc"
external = true
[[extra.product.footer_links.links]]
text = "Roadmap"
url = "/roadmap/"
[[extra.product.footer_links.links]]
text = "Changelog"
url = "https://github.com/raskell-io/bhc/blob/main/CHANGELOG.md"
external = true

[[extra.product.footer_links]]
title = "Community"
[[extra.product.footer_links.links]]
text = "Twitter / X"
url = "https://x.com/raskelll"
external = true
[[extra.product.footer_links.links]]
text = "Discussions"
url = "https://github.com/raskell-io/bhc/discussions"
external = true

[[extra.product.footer_links]]
title = "Legal"
[[extra.product.footer_links.links]]
text = "License (MIT)"
url = "https://github.com/raskell-io/bhc/blob/main/LICENSE"
external = true

# Navigation
[[extra.nav_links]]
name = "Get Started"
url = "/get-started/"

[[extra.nav_links]]
name = "Features"
dropdown = true
[[extra.nav_links.items]]
name = "Profiles"
url = "/profiles/"
desc = "Runtime compilation contracts"
[[extra.nav_links.items]]
name = "Numeric"
url = "/numeric/"
desc = "Tensor IR and SIMD"
[[extra.nav_links.items]]
name = "Targets"
url = "/targets/"
desc = "Native, WASM, GPU"

[[extra.nav_links]]
name = "Reference"
dropdown = true
[[extra.nav_links.items]]
name = "Compatibility"
url = "/compatibility/"
desc = "GHC edition support"
[[extra.nav_links.items]]
name = "Compiler"
url = "/compiler/"
desc = "Architecture deep dive"
[[extra.nav_links.items]]
name = "Docs"
url = "/docs/"
desc = "Full documentation"

[[extra.nav_links]]
name = "About"
url = "/about/"
